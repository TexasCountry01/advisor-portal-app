from django.db import models
from django.conf import settings
from django.core.validators import MinValueValidator, MaxValueValidator
from django.db.models.signals import post_delete
from django.dispatch import receiver
import os


def case_document_upload_path(instance, filename):
    """
    Rename uploaded files to include employee's last name (beneficiary).
    Format: [employee_lastname]_[original_filename].[ext]
    """
    if instance.case and instance.case.employee_last_name:
        last_name = instance.case.employee_last_name
        name, ext = os.path.splitext(filename)
        # Remove any existing last_name_ prefix to avoid duplicates
        if name.startswith(f"{last_name}_"):
            new_filename = filename
        else:
            new_filename = f"{last_name}_{filename}"
    else:
        new_filename = filename
    
    # Return path with date structure
    return os.path.join('case_documents', '%Y', '%m', '%d', new_filename)

class Case(models.Model):
    """Main case model with all 18 dashboard fields"""
    
    STATUS_CHOICES = [
        ('submitted', 'Submitted'),
        ('accepted', 'Accepted'),
        ('hold', 'Hold'),
        ('pending_review', 'Pending Review'),
        ('completed', 'Completed'),
    ]
    
    URGENCY_CHOICES = [
        ('normal', 'Normal'),
        ('urgent', 'Urgent'),
    ]
    
    TIER_CHOICES = [
        ('tier_1', 'Tier 1'),
        ('tier_2', 'Tier 2'),
        ('tier_3', 'Tier 3'),
    ]
    
    # Field 1: Case ID (auto-generated by benefits-software API)
    external_case_id = models.CharField(
        max_length=50, 
        unique=True,
        help_text='Generated by benefits-software API'
    )
    
    # Field 2: Workshop Code
    workshop_code = models.CharField(max_length=50)
    
    # Field 3: Member (Financial Advisor)
    member = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.PROTECT,
        related_name='submitted_cases',
        limit_choices_to={'role': 'member'}
    )
    
    # Created By (who actually submitted the case - could be delegate or advisor)
    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='created_cases',
        help_text='User who created this case (could be delegate submitting for advisor)'
    )
    
    # Field 4: Employee First Name
    employee_first_name = models.CharField(max_length=100)
    
    # Field 5: Employee Last Name
    employee_last_name = models.CharField(max_length=100)
    
    # Field 6: Client Email (required)
    client_email = models.EmailField()
    
    # Field 7: Number of Reports Requested (per case)
    num_reports_requested = models.PositiveIntegerField(default=1)
    
    # Field 8: Urgency
    urgency = models.CharField(max_length=10, choices=URGENCY_CHOICES, default='normal')
    
    # Field 9: Status
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='submitted')
    
    # Field 10: Assigned To (Technician)
    assigned_to = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='assigned_cases',
        limit_choices_to={'role': 'technician'}
    )
    
    # Field 11: Reviewed By (Level 2/3 Technician for Level 1 cases)
    reviewed_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='reviewed_cases',
        limit_choices_to={'role': 'technician', 'user_level__in': ['level_2', 'level_3']}
    )
    
    # Field 12: Tier (visible to technicians/admins only)
    tier = models.CharField(
        max_length=10, 
        choices=TIER_CHOICES, 
        blank=True,
        help_text='Tech/Admin only - not visible to members'
    )
    
    # Field 13: Date Submitted
    date_submitted = models.DateTimeField(auto_now_add=True)
    
    # Field 14: Date Accepted
    date_accepted = models.DateTimeField(null=True, blank=True)
    
    # Field 15: Date Due (visible to technicians/admins only)
    date_due = models.DateField(
        null=True, 
        blank=True,
        help_text='Tech/Admin only - not visible to members'
    )
    
    # Field 16: Date Scheduled (visible to technicians/admins only)
    date_scheduled = models.DateField(
        null=True, 
        blank=True,
        help_text='Tech/Admin only - not visible to members'
    )
    
    # Field 17: Date Completed
    date_completed = models.DateTimeField(null=True, blank=True)
    
    # Field 18: Report Notes (per-report status, stored as JSON)
    report_notes = models.JSONField(
        default=list,
        help_text='Array of report statuses for multi-report cases'
    )
    
    # Federal Fact Finder Data (structured JSON)
    fact_finder_data = models.JSONField(
        default=dict,
        blank=True,
        help_text='Federal Fact Finder form data in structured JSON format'
    )
    
    # PDF Generation Status
    PDF_STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('generating', 'Generating'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
    ]
    
    fact_finder_pdf_status = models.CharField(
        max_length=20,
        choices=PDF_STATUS_CHOICES,
        default='pending',
        help_text='Status of Federal Fact Finder PDF generation'
    )
    
    fact_finder_pdf_generated_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text='When the PDF was successfully generated'
    )
    
    # Special notes or requests from the member
    special_notes = models.TextField(
        blank=True,
        help_text='Special notes, requests, or additional information from the member'
    )
    
    # Preferred retirement date
    retirement_date_preference = models.DateField(
        null=True,
        blank=True,
        help_text='Preferred retirement date for analysis'
    )
    
    # API Sync Status
    API_SYNC_CHOICES = [
        ('pending', 'Pending'),
        ('synced', 'Synced'),
        ('failed', 'Failed'),
    ]
    
    api_sync_status = models.CharField(
        max_length=20,
        choices=API_SYNC_CHOICES,
        default='pending',
        help_text='Status of API sync to benefits-software'
    )
    
    api_synced_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text='When the case was successfully synced to benefits-software'
    )
    
    # Credit value assigned by technician (0.5, 1.0, 1.5, 2.0, 2.5, 3.0)
    credit_value = models.DecimalField(
        max_digits=3,
        decimal_places=1,
        null=True,
        blank=True,
        choices=[
            (0.5, '0.5'),
            (1.0, '1.0'),
            (1.5, '1.5'),
            (2.0, '2.0'),
            (2.5, '2.5'),
            (3.0, '3.0'),
        ],
        help_text='Credit value assigned by technician based on complexity and number of reports. Members can view but not change.'
    )
    
    # Additional fields for internal tracking
    notes = models.TextField(blank=True, help_text='Internal notes not visible to member')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        verbose_name = 'Case'
        verbose_name_plural = 'Cases'
        ordering = ['-date_submitted']
        indexes = [
            models.Index(fields=['external_case_id']),
            models.Index(fields=['status', '-date_submitted']),
            models.Index(fields=['member', '-date_submitted']),
            models.Index(fields=['assigned_to', 'status']),
        ]
    
    def __str__(self):
        return f"Case {self.external_case_id} - {self.employee_first_name} {self.employee_last_name}"
    
    @property
    def employee_full_name(self):
        return f"{self.employee_first_name} {self.employee_last_name}"
    
    @property
    def requires_review(self):
        """Check if case requires quality review (Level 1 technician)"""
        if self.assigned_to and self.assigned_to.user_level == 'level_1':
            return True
        return False


class CaseDocument(models.Model):
    """Documents uploaded for a case (Federal Fact Finder, additional files)"""
    
    DOCUMENT_TYPE_CHOICES = [
        ('fact_finder', 'Federal Fact Finder Form'),
        ('supporting', 'Supporting Document'),
        ('report', 'Generated Report'),
        ('other', 'Other'),
    ]
    
    case = models.ForeignKey(Case, on_delete=models.CASCADE, related_name='documents')
    document_type = models.CharField(max_length=20, choices=DOCUMENT_TYPE_CHOICES)
    file = models.FileField(upload_to=case_document_upload_path)
    original_filename = models.CharField(max_length=255)
    file_size = models.BigIntegerField()  # in bytes
    uploaded_by = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True)
    uploaded_at = models.DateTimeField(auto_now_add=True)
    notes = models.TextField(blank=True)
    
    class Meta:
        verbose_name = 'Case Document'
        verbose_name_plural = 'Case Documents'
        ordering = ['-uploaded_at']
    
    def __str__(self):
        return f"{self.original_filename} - Case {self.case.external_case_id}"


class CaseReport(models.Model):
    """Individual reports within a case (supports multi-report cases)"""
    
    REPORT_STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('in_progress', 'In Progress'),
        ('pending_review', 'Pending Review'),
        ('completed', 'Completed'),
    ]
    
    case = models.ForeignKey(Case, on_delete=models.CASCADE, related_name='reports')
    report_number = models.PositiveIntegerField()  # 1, 2, 3, etc. within the case
    status = models.CharField(max_length=20, choices=REPORT_STATUS_CHOICES, default='pending')
    assigned_to = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='assigned_reports'
    )
    reviewed_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='reviewed_reports'
    )
    report_file = models.FileField(upload_to='case_reports/%Y/%m/%d/', null=True, blank=True)
    notes = models.TextField(blank=True)
    started_at = models.DateTimeField(null=True, blank=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        verbose_name = 'Case Report'
        verbose_name_plural = 'Case Reports'
        ordering = ['case', 'report_number']
        unique_together = ('case', 'report_number')
    
    def __str__(self):
        return f"Report {self.report_number} - Case {self.case.external_case_id}"


class CaseNote(models.Model):
    """Internal notes/comments on cases (visible only to technicians/admins)"""
    
    case = models.ForeignKey(Case, on_delete=models.CASCADE, related_name='case_notes')
    author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True)
    note = models.TextField()
    is_internal = models.BooleanField(
        default=True,
        help_text='Internal notes not visible to members'
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        verbose_name = 'Case Note'
        verbose_name_plural = 'Case Notes'
        ordering = ['-created_at']
    
    def __str__(self):
        return f"Note by {self.author.username if self.author else 'Unknown'} on Case {self.case.external_case_id}"


class APICallLog(models.Model):
    """Log of all API calls to benefits-software for auditing and retry purposes"""
    
    case = models.ForeignKey(
        Case,
        on_delete=models.CASCADE,
        related_name='api_call_logs',
        help_text='Case associated with this API call'
    )
    
    endpoint = models.CharField(
        max_length=500,
        help_text='API endpoint URL called'
    )
    
    request_payload = models.JSONField(
        help_text='Request data sent to API'
    )
    
    response_status_code = models.IntegerField(
        null=True,
        blank=True,
        help_text='HTTP status code from API response'
    )
    
    response_data = models.JSONField(
        null=True,
        blank=True,
        help_text='Response data from API'
    )
    
    success = models.BooleanField(
        default=False,
        help_text='Whether the API call was successful'
    )
    
    error_message = models.TextField(
        blank=True,
        help_text='Error message if call failed'
    )
    
    attempt_number = models.IntegerField(
        default=1,
        help_text='Retry attempt number (1 = first attempt)'
    )
    
    created_at = models.DateTimeField(
        auto_now_add=True,
        help_text='When the API call was initiated'
    )
    
    completed_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text='When the API call completed (success or failure)'
    )
    
    class Meta:
        verbose_name = 'API Call Log'
        verbose_name_plural = 'API Call Logs'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['case', '-created_at']),
            models.Index(fields=['success', '-created_at']),
        ]
    
    def __str__(self):
        status = "Success" if self.success else "Failed"
        return f"{status} - Case {self.case.external_case_id} - Attempt {self.attempt_number}"


# Import FederalFactFinder from separate module (defined in models_fact_finder.py)
from .models_fact_finder import FederalFactFinder


# Signal handlers for file cleanup
@receiver(post_delete, sender=CaseDocument)
def delete_case_document_file(sender, instance, **kwargs):
    """Delete physical file when CaseDocument is deleted"""
    if instance.file:
        if os.path.isfile(instance.file.path):
            os.remove(instance.file.path)


@receiver(post_delete, sender=CaseReport)
def delete_case_report_file(sender, instance, **kwargs):
    """Delete physical file when CaseReport is deleted"""
    if instance.report_file:
        if os.path.isfile(instance.report_file.path):
            os.remove(instance.report_file.path)
